<!DOCTYPE html>
<html lang="en" class="js csstransforms3d">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Hugo 0.79.0" />
    <meta name="description" content="">


    <link rel="icon" href="/aprendaopengl/images/favicon.png" type="image/png">

    <title>Transformações :: Aprenda OpenGL</title>

    
    <link href="/aprendaopengl/css/nucleus.css?1609944863" rel="stylesheet">
    <link href="/aprendaopengl/css/fontawesome-all.min.css?1609944863" rel="stylesheet">
    <link href="/aprendaopengl/css/hybrid.css?1609944863" rel="stylesheet">
    <link href="/aprendaopengl/css/featherlight.min.css?1609944863" rel="stylesheet">
    <link href="/aprendaopengl/css/perfect-scrollbar.min.css?1609944863" rel="stylesheet">
    <link href="/aprendaopengl/css/auto-complete.css?1609944863" rel="stylesheet">
    <link href="/aprendaopengl/css/atom-one-dark-reasonable.css?1609944863" rel="stylesheet">
    <link href="/aprendaopengl/css/theme.css?1609944863" rel="stylesheet">
    <link href="/aprendaopengl/css/hugo-theme.css?1609944863" rel="stylesheet">
    
    <link href="/aprendaopengl/css/theme-mine.css?1609944863" rel="stylesheet">
    
    

    <script src="/aprendaopengl/js/jquery-3.3.1.min.js?1609944863"></script>

    <style>
      :root #header + #content > #left > #rlblock_left{
          display:none !important;
      }
      
    </style>
     <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };

  window.addEventListener('load', (event) => {
      document.querySelectorAll("mjx-container").forEach(function(x){
        x.parentElement.classList += 'has-jax'})
    });

</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


  </head>
  <body class="" data-url="/aprendaopengl/ponto_de_partida/transformacoes/">
    <nav id="sidebar" class="">



  <div id="header-wrapper">
    <div id="header">
      <a id="logo" href=''>
<img src="/aprendaopengl/images/logo.svg" width="100%" height="100%">
</a>

    </div>
    
        <div class="searchbox">
    <label for="search-by"><i class="fas fa-search"></i></label>
    <input data-search-input id="search-by" type="search" placeholder="Search...">
    <span data-search-clear=""><i class="fas fa-times"></i></span>
</div>

<script type="text/javascript" src="/aprendaopengl/js/lunr.min.js?1609944863"></script>
<script type="text/javascript" src="/aprendaopengl/js/auto-complete.js?1609944863"></script>
<script type="text/javascript">
    
        var baseurl = "https:\/\/filipecn.github.io\/aprendaopengl\/";
    
</script>
<script type="text/javascript" src="/aprendaopengl/js/search.js?1609944863"></script>

    
  </div>
  
    <section id="homelinks">
      <ul>
        <li>
            <a class="padding" href='/'><i class='fas fa-home'></i> Home</a>
        </li>
      </ul>
    </section>
  

    <div class="highlightable">
    <ul class="topics">

        
          
          




 
  
    
    <li data-nav-id="/aprendaopengl/introducao/" title="Introdução" class="dd-item
        
        
        
        ">
      <a href="/aprendaopengl/introducao/">
          <b>1. </b>Introdução
          
      </a>
      
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/aprendaopengl/ponto_de_partida/" title="Ponto de Partida" class="dd-item
        parent
        
        
        ">
      <a href="/aprendaopengl/ponto_de_partida/">
          <b>2. </b>Ponto de Partida
          
      </a>
      
      
        <ul>
          
          
            
          
          

        
          
            
            




 
  
    
    <li data-nav-id="/aprendaopengl/ponto_de_partida/opengl/" title="OpenGL" class="dd-item
        
        
        
        ">
      <a href="/aprendaopengl/ponto_de_partida/opengl/">
          OpenGL
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/aprendaopengl/ponto_de_partida/criando_uma_janela/" title="Criando uma Janela" class="dd-item
        
        
        
        ">
      <a href="/aprendaopengl/ponto_de_partida/criando_uma_janela/">
          Criando uma Janela
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/aprendaopengl/ponto_de_partida/ola_janela/" title="Olá Janela" class="dd-item
        
        
        
        ">
      <a href="/aprendaopengl/ponto_de_partida/ola_janela/">
          Olá Janela
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/aprendaopengl/ponto_de_partida/ola_triangulo/" title="Olá Triângulo" class="dd-item
        
        
        
        ">
      <a href="/aprendaopengl/ponto_de_partida/ola_triangulo/">
          Olá Triângulo
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/aprendaopengl/ponto_de_partida/transformacoes/" title="Transformações" class="dd-item
        parent
        active
        
        ">
      <a href="/aprendaopengl/ponto_de_partida/transformacoes/">
          Transformações
          
      </a>
      
      
    </li>
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/aprendaopengl/iluminacao/" title="Iluminação" class="dd-item
        
        
        
        ">
      <a href="/aprendaopengl/iluminacao/">
          <b>3. </b>Iluminação
          
      </a>
      
      
        <ul>
          
          
            
          
          

        
          
            
            




 
  
    
    <li data-nav-id="/aprendaopengl/iluminacao/cores/" title="Cores" class="dd-item
        
        
        
        ">
      <a href="/aprendaopengl/iluminacao/cores/">
          Cores
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/aprendaopengl/iluminacao/iluminacao_basica/" title="Iluminação Básica" class="dd-item
        
        
        
        ">
      <a href="/aprendaopengl/iluminacao/iluminacao_basica/">
          Iluminação Básica
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/aprendaopengl/iluminacao/materiais/" title="Materiais" class="dd-item
        
        
        
        ">
      <a href="/aprendaopengl/iluminacao/materiais/">
          Materiais
          
      </a>
      
      
    </li>
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/aprendaopengl/iluminacao_avancada/" title="Iluminação Avançada" class="dd-item
        
        
        
        ">
      <a href="/aprendaopengl/iluminacao_avancada/">
          <b>6. </b>Iluminação Avançada
          
      </a>
      
      
        <ul>
          
          
            
          
          

        
          
            
            




 
  
    
    <li data-nav-id="/aprendaopengl/iluminacao_avancada/sombras/" title="Sombras" class="dd-item
        
        
        
        ">
      <a href="/aprendaopengl/iluminacao_avancada/sombras/">
          <b>X. </b>Sombras
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/aprendaopengl/iluminacao_avancada/iluminacao_avancada/" title="Iluminação Avançada" class="dd-item
        
        
        
        ">
      <a href="/aprendaopengl/iluminacao_avancada/iluminacao_avancada/">
          Iluminação Avançada
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
      <li data-nav-id="/aprendaopengl/iluminacao_avancada/correcao_gama/index_/" title="Correção Gama" class="dd-item ">
        <a href="/aprendaopengl/iluminacao_avancada/correcao_gama/index_/">
        Correção Gama
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
          




 
  
    
    <li data-nav-id="/aprendaopengl/pbr/" title="PBR" class="dd-item
        
        
        
        ">
      <a href="/aprendaopengl/pbr/">
          <b>7. </b>PBR
          
      </a>
      
      
        <ul>
          
          
            
          
          

        
          
            
            




 
  
    
    <li data-nav-id="/aprendaopengl/pbr/teoria/" title="Teoria" class="dd-item
        
        
        
        ">
      <a href="/aprendaopengl/pbr/teoria/">
          Teoria
          
      </a>
      
      
    </li>
  
 

            
          
            
            




 
  
    
    <li data-nav-id="/aprendaopengl/pbr/iluminacao/" title="Iluminação" class="dd-item
        
        
        
        ">
      <a href="/aprendaopengl/pbr/iluminacao/">
          Iluminação
          
      </a>
      
      
    </li>
  
 

            
          
        
        </ul>
      
    </li>
  
 

          
        
    </ul>

    
    
      <section id="shortcuts">
        <h3>More</h3>
        <ul>
          
              <li>
                  <a class="padding" href="https://github.com/filipecn/aprendaopengl"><i class='fab fa-github'></i> Github repo</a>
              </li>
          
              <li>
                  <a class="padding" href="https://filipecn.github.io/aprendaopengl/credits"><i class='fas fa-bullhorn'></i> Credits</a>
              </li>
          
        </ul>
      </section>
    

    
    <section id="footer">
      <center>
    Conteúdo originalmente criado por /
    <p>todos direitos reservados para</p>
    <p><a href="https://twitter.com/JoeyDeVriez">Joey De Vriez</a></p>
    <p>Construído com <a href="https://github.com/matcornic/hugo-theme-learn"><i class="fas fa-heart"></i></a> usando <a href="https://getgrav.org">Grav</a> e <a href="https://gohugo.io/">Hugo</a></p>
</center>


    </section>
  </div>
</nav>




        <section id="body">
        <div id="overlay"></div>
        <div class="padding highlightable">
              
              <div>
                <div id="top-bar">
                
                  
                  
                  
                  <div id="top-github-link">
                    <a class="github-link" title='Edit this page' href="https://github.com/filipecn/aprendaopengl/tree/main/content/ponto_de_partida/transformacoes/_index.md" target="blank">
                      <i class="fas fa-code-branch"></i>
                      <span id="top-github-link-text">Edit this page</span>
                    </a>
                  </div>
                  
                
                
                <div id="breadcrumbs" itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb">
                    <span id="sidebar-toggle-span">
                        <a href="#" id="sidebar-toggle" data-sidebar-toggle="">
                          <i class="fas fa-bars"></i>
                        </a>
                    </span>
                  
                  <span id="toc-menu"><i class="fas fa-list-alt"></i></span>
                  
                  <span class="links">
                 
                 
                    
          
          
            
            
          
          
            
            
          
          
            <a href='/aprendaopengl/'>home</a> > <a href='/aprendaopengl/ponto_de_partida/'>Ponto de Partida</a> > Transformações
          
        
          
        
          
        
                 
                  </span>
                </div>
                
                    <div class="progress">
    <div class="wrapper">

    </div>
</div>

                
              </div>
            </div>
            
        <div id="head-tags">
        
        </div>
        
        <div id="body-inner">
          
            <h1>
              
              Transformações
            </h1>
          

        



	<p><a href="https://learnopengl.com/Getting-started/Transformations">Post Original</a></p>

<p>Sabemos agora como criar objetos, colorir-los e/ou dar-lhes uma aparência detalhada usando texturas, mas eles ainda não são tão interessantes, pois eles são todos objetos estáticos. Poderíamos tentar mover-los ao mudar seus vértices e re-configurar seus buffers a cada quadro, mas isso é complicado e custa bastante poder de processamento. Há muitas maneiras melhores de se <span style="color:green">transformar </span>
 um objeto e isso é usando (múltiplos) objetos de matriz ( <span style="color:green">matrix </span>
). Isso não significa que nós iremo falar sobre Kung Fu e um grande mundo artificial digital.</p>

<p>Matrizes são construções matemáticas muito poderosas que parecem assustadoras no começo, mas uma vez que você se acostuma a elas, vão revelar-se extremamente úteis. Ao discutir matrizes, teremos que mergulhar em um pouco de matemática e para os leitores mais inclinados a matemática  vou postar recursos adicionais para leituras posteriores.</p>

<p>No entanto, para compreender plenamente as transformações, primeiro temos que aprofundar um pouco mais em vetores antes de discutir matrizes. O foco deste capítulo é dar-lhe uma base matemática em temas que iremos precisar mais tarde. Se as matérias estiverem difíceis, tente compreendê-las o tanto quanto você puder e volte a este capítulo mais tarde para rever os conceitos sempre que você precisar deles.</p>

<h2 id="vetores">Vetores</h2>

<p>Em sua definição mais básica, vetores são <em>direções</em> e nada mais. Um vetor tem uma <span style="color:green">direção </span>
 e uma <span style="color:green">magnitude </span>
 (também conhecida como a sua força ou comprimento). Você pode pensar em vetores como instruções sobre um mapa do tesouro: 'Ande 10 passos para esquerda, agora ande 3 passos na direção norte e 5 passos para direita'; aqui 'esquerda' é a direção e '10 passos' é a magnitude do vetor. As indicações para o mapa do tesouro, portanto, contém 3 vetores. Vetores podem ter qualquer dimensão, mas geralmente trabalhamos com dimensões de 2 a 4. Se um vetor tem 2 dimensões,  representa uma direção em um plano (pense em gráficos 2D) e quando ele tem 3 dimensões pode representar qualquer direção em um mundo 3D.</p>

<p>Abaixo, você verá 3 vetores, onde cada vetor é representado com $(x, y)$ como flechas em um gráfico 2D. Como é mais intuitivo para exibir vetores em 2D (ao invés de 3D) você pode pensar dos vetores 2D como vetores 3D com a coordenada $z$ valendo $0$. Já que vetores representam direções, a origem do vetor não muda o seu valor. No gráfico abaixo, podemos ver que os vetores $\bar{v}$ e $\bar{w}$ são iguais mesmo que suas origens sejam diferentes:</p>

<p><figure><img src="https://learnopengl.com/img/getting-started/vectors.png" alt="altlogo"></figure></p>

<p>Quando os matemáticos descrevem vetores, geralmente preferem descreve-los através de símbolos com uma barra sobre sua cabeça, como $\bar{v}$. Além disso, em fórmulas eles são geralmente apresentados como se segue:</p>

<p><span  class="math">\[\bar{v} = \begin{pmatrix} x \\  y \\  z \end{pmatrix}\]</span></p>

<p>Porque vetores são especificados como direções às vezes é difícil visualizá-los como posições. Se quisermos visualizar vetores como posições podemos imaginar a origem do vetor de direção sendo $(0,0,0)$ e depois apontar para uma certa direção que especifica o ponto, tornando-se um <span style="color:green">vetor posição </span>
 (que também pode especificar uma origem  diferente e, em seguida, dizer: 'este vetor aponta para esse ponto no espaço a partir desta origem'). O vetor de posição $(3,5)$ apontaria para $(3,5)$ no gráfico com uma origem de $(0,0)$. Usando vetores podemos assim descrever direções <strong>e</strong> posições no espaço 2D e 3D.</p>

<p>Assim como com números normais também pode definir várias operações em vetores (alguns dos quais você já viu).</p>

<h2 id="operações-escalares-de-vetores">Operações Escalares de Vetores</h2>

<p>Um <span style="color:green">escalar </span>
 é um único número. Ao adicionar / subtrair / multiplicar ou dividir um vetor com um escalar nós simplesmente adicionamos / subtraimos / multiplicamos ou dividimos cada elemento do vetor pelo escalar. Para adição, ficaria assim:</p>

<p><span  class="math">\[\begin {pmatrix}  1 \\  2 \\ 3 \end{pmatrix} + x \rightarrow \begin{pmatrix} 1 \\ 2 \\  3 \end{pmatrix} + \begin{pmatrix} x \\ x \\ x \end{pmatrix} = \begin{pmatrix} 1 + x \\ 2 + x \\ 3 + x \end{pmatrix}\]</span></p>

<p>Onde $+$ pode ser $+$, $-$, $\cdot$ ou $\div$ onde $\cdot$ é o operador de multiplicação.</p>

<h2 id="negação-de-vetores">Negação de Vetores</h2>

<p>Negar um vetor resulta em um vetor na direção contrária. Um vetor que aponta na direção nordeste apontaria para o sudoeste depois de negação. Para negar um vetor, adicionamos um sinal de menos em cada componente (você também pode representá-lo como uma multiplicação escalar-vetor com um valor escalar $-1$):</p>

<p><span  class="math">\[-\bar{v} = -\begin{pmatrix} v_x \\ v_y \\ v_z \end{pmatrix} = \begin{pmatrix} - v_x \\ - v_y \\ - v_z \end{pmatrix}\]</span></p>

<h2 id="adição-e-subtração">Adição e Subtração</h2>

<p>A adição de dois vetores é definida como a adição por componente ( <span style="color:green">component-wise </span>
), isto é, cada componente de um vetor é adicionada a mesma componente do outro vetor da seguinte forma:</p>

<p><span  class="math">\[\bar{v} = \begin{pmatrix} 1 \\  2 \\ 3 \end{pmatrix}, \bar{k} = \begin{pmatrix}  4 \\  5 \\  6 \end{pmatrix} \rightarrow \bar{v} + \bar{k} = \begin{pmatrix}  1 +  4 \\ 2 + 5 \\  3 + 6 \end{pmatrix} = \begin{pmatrix} 5 \\ 7 \\ 9 \end{pmatrix}\]</span></p>

<p>Visualmente, para os vetores <strong>v = (4,2)</strong> e <strong>k = (1,2)</strong>, em que o segundo vetor é adicionado em cima da extremidade do primeiro vetor para encontrar o ponto final do vetor resultante (método <em>head-to-tail</em>):</p>

<p><figure><img src="https://learnopengl.com/img/getting-started/vectors_addition.png" alt="altlogo"></figure></p>

<p>Assim como adição e subtração normais, a subtração de vetores é o mesmo que a adição com o segundo vetor negado:</p>

<p><span  class="math">\[\bar{v} = \begin{pmatrix} 1 \\ 2 \\ 3 \end{pmatrix}, \bar{k} = \begin{pmatrix}  4 \\ 5 \\ 6 \end{pmatrix} \rightarrow \bar{v} + - \bar{k} = \begin{pmatrix} 1 + (-4) \\ 2 + (-5) \\ 3 + (-6) \end{pmatrix} = \begin{pmatrix} - 3 \\ - 3 \\ -3 \end{pmatrix}\]</span></p>

<p>Subtraindo-se dois vetores um do outro resulta num vetor que é a diferença das posições que apontam ambos os vetores. Isso se prova útil em certos casos em que precisamos recuperar um vetor que é a diferença entre dois pontos.</p>

<p><figure><img src="https://learnopengl.com/img/getting-started/vectors_subtraction.png" alt="altlogo"></figure></p>

<h2 id="comprimento-length">Comprimento (Length)</h2>

<p>Para recuperar o comprimento/magnitude de um vetor usamos o <span style="color:green">teorema de Pitágoras </span>
 que você pode se lembrar de suas aulas de matemática. Um vetor forma um triângulo quando visualizamos sua componentes individuais <strong>x</strong> e <strong>y</strong> como dois lados de um triângulo:</p>

<p><figure><img src="https://learnopengl.com/img/getting-started/vectors_triangle.png" alt="altlogo"></figure></p>

<p>Já o comprimento dos dois lados <strong>(x, y)</strong> são conhecidos e queremos saber o comprimento do lado inclinado $\bar{v}$, podemos calcula-lo usando o teorema de Pitágoras:</p>

<p><span  class="math">\[|| \bar{v}|| = \sqrt{  x^2 + y^2}\]</span></p>

<p>Onde $||\bar{v}||$ é denotado como o <em>comprimento do vetor</em> $\bar{v}$. Isto é facilmente estendido para 3D adicionando $z^2$ para a equação.</p>

<p>Neste caso, o comprimento do vetor <strong>(4, 2)</strong> é igual a:</p>

<p><span  class="math">\[||\bar{v}|| = \sqrt{ 4^2 + 2^2} = \sqrt{16 +  4} = \sqrt{20} = 4.47\]</span></p>

<p>Que é <strong>4.47</strong>.</p>

<p>Há também um tipo especial de vetor que nós chamamos um <span style="color:green">vetor unitário </span>
 ( <span style="color:green">unit vetor </span>
). Um vetor unitário tem uma propriedade extra que é que seu comprimento é exatamente <strong>1</strong>. Nós podemos calcular um vetor unitário $\hat{n}$ a partir de qualquer vetor, dividindo cada um dos componentes do vetor por seu comprimento:</p>

<p><span  class="math">\[\hat{n} = \frac{\bar{v}}{|| \bar{v} ||}\]</span></p>

<p>Chamamos isso de <span style="color:green">normalizar </span>
 um vetor. Vetores unitários são exibidos com um chapéu sobre sua cabeça e geralmente são mais fáceis de trabalhar, especialmente quando nos preocupamos apenas com suas direções (a direção não muda se mudarmos o comprimento de um vetor).</p>

<h2 id="multiplicação-vetorvetor">Multiplicação Vetor-Vetor</h2>

<p>A multiplicação de dois vetores se trata de um caso um pouco estranho. A multiplicação normal não está realmente definida em vetores, uma vez que não tem sentido visual, mas temos dois casos específicos dos quais que poderíamos escolher ao multiplicar: um é o produto escalar ( <span style="color:green">dot product </span>
) denotado como $\bar{v} \cdot \bar {k}$ e o outro é o produto vetorial ( <span style="color:green">cross product </span>
) denotado como $\bar{v} \times \bar{k}$.</p>

<h3 id="produto-escalar">Produto Escalar</h3>

<p>O produto escalar de dois vetores é igual ao produto escalar dos seus comprimentos vezes o coseno do ângulo entre eles. Se isso soa confuso, dê uma olhada na sua fórmula:</p>

<p><span  class="math">\[\bar{v} \cdot \bar{k} = || \bar{v} || \cdot || \bar{k} || \cdot \cos \theta\]</span></p>

<p>Onde o ângulo entre eles é representado por theta ($\theta$). Por que isso é interessante? Bem, imagine se $\bar{v}$ e $\bar{k}$ são vetores unitários. Isso efetivamente reduz a fórmula para:</p>

<p><span  class="math">\[\hat{v} \cdot \hat{k} = 1 \cdot 1 \cdot \cos \theta = \cos \theta\]</span></p>

<p>Agora, o produto escalar só define o ângulo entre os dois vetores. Você pode se lembrar que o coseno ou a função <strong>cos</strong> se torna <strong>0</strong> quando o ângulo é de <strong>90</strong> graus ou <strong>1</strong> quando o ângulo é <strong>0</strong>. Isso nos permite facilmente testar se os dois vetores são <span style="color:green">ortogonais </span>
 ou <span style="color:green">paralelos </span>
 entre si usando o produto escalar (ortogonais significa que os vetores formam um <span style="color:green">ângulo reto </span>
 um com o outro). No caso de você querer saber mais sobre as funções <strong>sin</strong> e <strong>cos</strong> sugiro os seguintes <a href="https://www.khanacademy.org/math/trigonometry/basic-trigonometry/basic_trig_ratios/v/basic-trigonometry">vídeos da Khan Academy</a> sobre trigonometria básica.</p>


<div class="mynotices tip" ><p>Você também pode calcular o ângulo entre dois vetores não-unitários, dividindo os comprimentos de ambos vetores do resultado a ser deixado com $\cos \theta$.</p>
</div>


<p>Então, como podemos calcular o produto escalar? O produto escalar é a multiplicação por componente onde adicionamos os resultados. Com dois vetores unitários (você pode verificar que ambos os seus comprimentos são exatamente <strong>1</strong>):</p>

<p><span  class="math">\[\begin{pmatrix} 0.6 \\ - 0.8 \\ 0 \end{pmatrix} \cdot \begin{pmatrix} 0 \\ 1 \\ 0 \end{pmatrix} = 0.6 * 0) + (-0.8 * 1) + (0 * 0) = -0.8\]</span></p>

<p>Para calcular o ângulo entre estes dois vetores unitários, usamos o inverso da função coseno $\cos^{-1}$ e isto resulta em <strong>143.1</strong> graus. Nós agora efetivamente calculamos o ângulo entre esses dois vetores. O produto escalar será muito útil para fazer cálculos de iluminação mais tarde.</p>

<h3 id="produto-vetorial">Produto Vetorial</h3>

<p>O produto vetorial é apenas definido no espaço 3D e leva dois vetores não-paralelos como entrada e produz um terceiro vetor que é ortogonal a ambos os vetores de entrada. Se ambos os vetores de entrada são ortogonais entre si, o produto vetorial resultaria em 3 vetores ortogonais; isso vai ser útil nos próximos capítulos. A imagem seguinte mostra como isso parece no espaço 3D:</p>

<p><figure><img src="https://learnopengl.com/img/getting-started/vectors_crossproduct.png" alt="altlogo"></figure></p>

<p>Ao contrário das outras operações, o produto vetorial não é muito intuitivo sem aprofundarmos na álgebra linear, por isso é melhor apenas memorizar a fórmula e você vai ficar bem (ou não, você provavelmente vai ficar bem também). Abaixo, você verá o produto vetorial entre dois vetores ortogonais <strong>A</strong> e <strong>B</strong>:</p>

<p><span  class="math">\[\begin{pmatrix} A_{x} \\ A_y \\ A_ {z} \end{pmatrix} \times \begin{pmatrix} B_{x} \\ B_y \\ B_{z} \end{pmatrix} = \begin{pmatrix} A_{y} \cdot B_{z} - A_{z} \cdot B_{y} \\ A_{z} \cdot B_{x} - A_{x} \cdot B_{z} \\ A_{x} \cdot B_{y} - A_{y} \cdot B_{x} \end{pmatrix}\]</span></p>

<p>Como você pode ver, ele realmente não parece fazer sentido. No entanto, se você apenas seguir estes passos você obterá um outro vetor que é perpendicular aos seus vetores de entrada.</p>

<h2 id="matrizes">Matrizes</h2>

<p>Agora que nós discutimos quase tudo o que há de vetores é hora de entrar na <em>Matrix!</em> Uma  matriz é um array retangular de números, símbolos e/ou expressões matemáticas. Cada item individual numa matriz é chamado um <span style="color:green">elemento </span>
 da matriz. Um exemplo de uma matriz de <strong>2x3</strong> é mostrado abaixo:</p>

<p><span  class="math">\[\begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \end{bmatrix}\]</span></p>

<p>As matrizes são indexadas por <strong>(i, j)</strong>, onde <strong>i</strong> é a linha e <strong>j</strong> é a coluna, por isso a matriz acima é chamada uma matriz de <strong>2x3</strong> (<strong>3</strong> colunas e <strong>2</strong> linhas, também conhecida como as <span style="color:green">dimensões </span>
 da matriz). Este é o oposto do que você está acostumado ao indexar gráficos 2D como <strong>(x, y)</strong>. Para recuperar o valor <strong>4</strong> teríamos posicioná-lo como <strong>(2,1)</strong> (segunda linha, primeira coluna).</p>

<p>Matrizes são basicamente nada mais do que isso, apenas arrays retangulares de expressões matemáticas. Elas têm um conjunto de propriedades matemáticas muito bom e, assim como vetores podemos definir várias operações sobre matrizes como: adição, subtração e multiplicação.</p>

<h3 id="adição-e-subtração-1">Adição e Subtração</h3>

<p>A adição e subtração entre duas matrizes são feitas em uma base por-elemento. Assim, as mesmas regras gerais com os números normais de que estamos familiarizados aplicam-se, mas feito sobre os elementos de ambas as matrizes com o mesmo índice. Isto significa que a adição e subtração só é definida para matrizes com as mesmas dimensões. Uma matriz 3x2 e uma matriz de 2x3 (ou uma matriz 3x3 e uma matriz 4x4) não podem ser adicionadas ou subtraídas. Vamos ver como a adição de matriz funciona em duas matrizes 2x2:</p>

<p><span  class="math">\[\begin{bmatrix}  1 &  2 \\ 3 &  4 \end{bmatrix} + \begin{bmatrix} 5 & 6 \\ 7 & 8 \end{bmatrix} = \begin{bmatrix} 1 + 5 & 2 + 6 \\ 3 +  7 &  4 + 8 \end{bmatrix} = \begin{bmatrix}  6 &  8 \\ 10 & 12 \end{bmatrix}\]</span></p>

<p>As mesmas regras se aplicam para a subtração de matriz:</p>

<p><span  class="math">\[\begin{bmatrix}  4 &  2 \\  1 &  6 \end{bmatrix} - \begin{bmatrix}  2 &  4 \\  0 &  1 \end{bmatrix} = \begin{bmatrix}  4 -  2 &  2 -  4 \\  1 -  0 &  6 -  1 \end{bmatrix} = \begin{bmatrix}  2 & -2 \\  1 &  5 \end{bmatrix}\]</span></p>

<h2 id="produtos-matrizescalar">Produtos Matriz-Escalar</h2>

<p>Um produto matriz-escalar multiplica cada elemento da matriz pelo escalar. O exemplo a seguir ilustra a multiplicação:</p>

<p><span  class="math">\[ 2 \cdot \begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix} = \begin{bmatrix}  2 \cdot 1 & 2 \cdot 2 \\  2 \cdot 3 &  2 \cdot 4 \end{bmatrix} = \begin{bmatrix} 2 & 4 \\ 8 & 6 \end{bmatrix} \]</span></p>

<p>Agora também faz sentido a respeito de porque esses números individuais são chamados de escalares. Um escalar basicamente <em>escala</em> todos os elementos da matriz pelo seu valor. No exemplo anterior, todos os elementos foram escalados por dois.</p>

<p>Até aí tudo bem, todos os nossos casos não foram realmente muito complicados. Isto é, até começarmos com a multiplicação matriz-matriz.</p>

<h2 id="multiplicação-matrizmatriz">Multiplicação Matriz-Matriz</h2>

<p>Multiplicar as matrizes não é necessariamente complexo, mas bastante difícil de se sentir confortável com. A multiplicação de matrizes significa, basicamente, seguir um conjunto de regras pré-definidas. Existem algumas restrições, porém:</p>

<ol>
<li><p>Você só pode multiplicar duas matrizes se o número de colunas na matriz do lado esquerdo é igual ao número de linhas na matriz do lado direito.</p></li>

<li><p>A multiplicação de matrizes não é <span style="color:green">comutativa </span>
, que é $A \cdot B \neq B \cdot A$.</p></li>
</ol>

<p>Vamos começar com um exemplo de uma multiplicação de 2 matrizes <strong>2x2</strong>:</p>

<p><span  class="math">\[\begin{bmatrix}  1 &  2 \\  3 &  4 \end{bmatrix} \cdot \begin{bmatrix} \  5 &  6 \\  7 &  8 \end{bmatrix} = \begin{bmatrix}  1 \cdot 5 +  2 \cdot  7 &  1 \cdot  6 +  2 \cdot  8 \\ 3 \cdot  5 +  4 \cdot  7 &  3 \cdot  6 +  4 \cdot  8 \end{bmatrix} = \begin{bmatrix} 19 & 22 \\ 43 & 50 \end{bmatrix}\]</span></p>

<p>Agora você provavelmente está tentando descobrir o que diabos aconteceu? A multiplicação de matrizes é uma combinação de multiplicação e adição normais utilizando as linhas da matriz esquerda com colunas da matriz direita. Vamos tentar discutir isso com a seguinte imagem:</p>

<p><figure><img src="https://learnopengl.com/img/getting-started/matrix_multiplication.png" alt="altlogo"></figure></p>

<p>Em primeiro lugar, tomamos a linha superior da matriz esquerda e depois tomamos uma coluna da matriz direita. A linha e coluna que escolhemos decide que valor da matriz <strong>2x2</strong> vamos calcular. Se tomarmos a primeira linha da matriz esquerda o valor resultante vai acabar na primeira linha da matriz resultante, então nós escolhemos uma coluna e se é a primeira coluna o valor do resultado vai acabar na primeira coluna da matriz resultante. Este é exatamente o caso do caminho vermelho. Para calcular o resultado inferior direito tomamos a linha inferior da primeira matriz e da coluna mais à direita da segunda matriz.</p>

<p>Para calcular o valor resultante multiplicamos os primeiros elementos da linha e da coluna, utilizando multiplicação normal, fazemos o mesmo para os segundos elementos, terceiros, quartos, etc. Os resultados das multiplicações individuais são então somados e temos o nosso resultado. Agora, também faz sentido que um dos requisitos é que o tamanho das colunas de matriz esquerda e o número de linhas da matriz direita sejam iguais, caso contrário, não podemos terminar as operações!</p>

<p>O resultado é, em seguida, uma matriz que tem dimensões de <strong>(n, m)</strong>, onde <strong>n</strong> é igual ao número de linhas da matriz do lado esquerdo e <strong>m</strong> é igual ao número de colunas da matriz do lado direito.</p>

<p>Não se preocupe se você tem dificuldades imaginando as multiplicações dentro de sua cabeça. Apenas continue tentando fazer os cálculos à mão e retorne a esta página sempre que você tiver dificuldades. Com o tempo, a multiplicação de matrizes torna-se natural para você.</p>

<p>Vamos acabar com a discussão de multiplicação de matriz-matriz com um exemplo maior. Tente visualizar o padrão usando as cores. Como um exercício útil, veja se você consegue chegar sozinho(a) a mesma resposta (uma vez que você tentar fazer uma multiplicação de matrizes à mão você vai rapidamente obter a compreensão delas).</p>

<p><span  class="math">\[\begin{bmatrix}  4 &  2 &  0 \\  0 &  8 &  1 \\  0 &  1 &  0 \end{bmatrix} \cdot \begin{bmatrix}  4 &  2 &  1 \\  2 &  0 &  4 \\  9 &  4 &  2 \end{bmatrix} = \begin{bmatrix}  4 \cdot  4 +  2 \cdot  2 +  0 \cdot  9 &   4 \cdot  2 +   2 \cdot  0 +   0 \cdot 4 & 4 \cdot  1 +  2 \cdot  4 + 0 \cdot  2 \\  0 \cdot   4 +  8 \cdot   2 +  1 \cdot   9 &  0 \cdot   2 +  8 \cdot  0 +  1 \cdot  4 &  0 \cdot  1 +  8 \cdot  4 +  1 \cdot  2 \\  0 \cdot  4 + 1 \cdot  2 +  0 \cdot   9 &  0 \cdot  2 +  1 \cdot  0 +  0 \cdot  4 &  0 \cdot  1 +  1 \cdot  4 +  0 \cdot  2 \end{bmatrix}
 \\ = \begin{bmatrix} 20 & 8 & 12 \\ 25 & 4 & 34 \\ 2 & 0 & 4 \end{bmatrix}\]</span></p>

<p>Como você pode ver, a multiplicação de matrizes é um processo bastante complicado e muito propenso a erros (é por isso que normalmente deixamos para os computadores fazerem) e isso fica problemático bem rápido quando as matrizes se tornam maiores. Se você ainda está sedento por mais e você está curioso sobre mais algumas das propriedades matemáticas de matrizes eu sugiro fortemente que você dê uma olhada nestes <a href="https://www.khanacademy.org/math/algebra2/algebra-matrices">vídeos da Khan Academy</a> a cerca de matrizes.</p>

<p>De qualquer forma, agora que sabemos como multiplicar matrizes, podemos começar com as coisas boas agora.</p>

<h2 id="multiplicação-matrizvetor">Multiplicação Matriz-Vetor</h2>

<p>Até agora nós tivemos nossa boa parcela de vetores. Nós os utilizamos para representar posições, cores e até mesmo coordenadas de textura. Vamos adentrar mais um pouco na toca do coelho e dizer que um vetor é basicamente uma matriz <strong>Nx1</strong>, onde <strong>N</strong> é o número de componentes do vetor (também conhecido como um vetor <span style="color:green">n-dimensional </span>
). Se você pensar sobre isso, faz muito sentido. Os vetores são como matrizes, um array de números, mas com apenas uma coluna. Então, como esta nova informação nos ajuda? Bem, se temos uma matriz <strong>MxN</strong> podemos multiplicar esta matriz com o nosso vetor <strong>Nx1</strong>, já que o número de colunas da matriz é igual ao número de linhas do vetor, assim, a multiplicação de matrizes é definida.</p>

<p>Mas porque é que nós nos importamos se podemos multiplicar matrizes com um vetor? Bem, acontece que há muitas transformações 2D / 3D interessantes que podemos colocar dentro de uma matriz, e multiplicando a matriz com um vetor, em seguida, transformamos esse vetor. No caso de você ainda estar um pouco confuso, vamos começar com alguns exemplos e em breve você vai ver o que queremos dizer.</p>

<h3 id="matriz-identidade">Matriz Identidade</h3>

<p>Em OpenGL normalmente trabalhamos com matrizes de transformação <strong>4x4</strong> por várias razões e uma delas é que a maioria dos vetores são de tamanho <strong>4</strong>. A matriz de transformação mais simples que podemos pensar é a matriz identidade. A matriz de identidade é uma matriz <strong>NxN</strong> com apenas <strong>0</strong>s exceto na sua diagonal. Como você verá, esta transformação de matriz deixa um vetor completamente ileso:</p>

<p><span  class="math">\[\begin{bmatrix}  1 &  0 &  0 &  0 \\  0 &  1 &  0 &  0 \\  0 &  0 &  1 &  0 \\ 0 &  0 &  0 &  1 \end{bmatrix} \cdot \begin{bmatrix} 1 \\ 2 \\ 3 \\ 3 \end{bmatrix} = \begin{bmatrix}  1 \cdot 1 \\  1 \cdot 2 \\  1 \cdot 3 \\  1 \cdot 4 \end{bmatrix} = \begin{bmatrix} 1 \\  2\\3 \\ 4 \end{bmatrix}\]</span></p>

<p>O vetor está completamente intacto. Isto torna-se óbvio a partir das regras de multiplicação: o primeiro elemento é resultado de cada elemento individual da primeira linha da matriz multiplicado com cada elemento do vetor. Uma vez que cada um dos elementos da linha são 0, exceto a primeira, obtemos: $ 1 \cdot 1 +  0 \cdot 2 +  0 \cdot 3 +   0 \cdot 4 = 1$ e o mesmo se aplica para os outros <strong>3</strong> elementos do vetor.</p>


<div class="mynotices tip" ><p>Você pode estar se perguntando qual é o uso de uma matriz de transformação que não transforma? A matriz de identidade é geralmente um ponto de partida para gerar outras matrizes de transformação e, se cavar ainda mais fundo álgebra linear, uma matriz muito útil para demonstração de teoremas e resolução de equações lineares.</p>
</div>


<h3 id="escala">Escala</h3>

<p>Quando escalamos um vetor estamos aumentando o comprimento da flecha pela quantidade que gostaríamos de escalar, mantendo sua direção. Uma vez que estamos trabalhando em 2 ou 3 dimensões, podemos definir a escala por um vetor de 2 ou 3 variáveis ​​de escalonamento, cada uma dimensionando um eixo (<strong>x</strong>, <strong>y</strong> ou <strong>z</strong>).</p>

<p>Vamos tentar escalar o vetor $\bar{v} = (3,2)$. Vamos escalar o vetor ao longo do eixo <strong>x</strong> por <strong>0.5</strong>, tornando-se, assim, duas vezes mais estreito; e vamos escalar o vetor por <strong>2</strong> ao longo do eixo <strong>y</strong>, tornando-se duas vezes mais alto. Vamos ver o que acontece se dimensionarmos o vetor por <strong>(0.5,2)</strong> como $\bar{s}$:</p>

<p><figure><img src="https://learnopengl.com/img/getting-started/vectors_scale.png" alt="altlogo"></figure></p>

<p>Tenha em mente que OpenGL normalmente opera no espaço 3D, então para este caso 2D poderíamos definir a escala do eixo <strong>z</strong> como <strong>1</strong>, deixando-a ilesa. A operação de escala que acabamos de realizar se trata de uma <span style="color:green">escala não uniforme </span>
, porque o fator de escala não é o mesmo para cada eixo. Se o escalar fosse igual em todos os eixos seria chamada de uma <span style="color:green">escala uniforme </span>
.</p>

<p>Vamos começar a construir uma matriz de transformação que faz a escala. Vimos a partir da matriz de identidade que cada um dos elementos da diagonal foram multiplicados com o seu elemento de vetor correspondente. E se mudássemos os <strong>1</strong>s na matriz de identidade para <strong>3</strong>s? Nesse caso, estaríamos multiplicando cada um dos elementos do vetor por um valor de 3 e assim, efetivamente uniformemente escalaríamos o vetor por <strong>3</strong>. Se representarmos as variáveis ​​de escala como $(S_1, S_2, S_3)$, podemos definir uma matriz de dimensionamento em qualquer vetor $(x, y, z)$ como:</p>

<p><span  class="math">\[\begin{bmatrix} S_1 &  0 &  0 &  0 \\  0 &  S_2 &  0 &  0 \\  0 &  0 &  S_3 &  0 \\  0 &  0 &  0 &  1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix}  S_1 \cdot x \\ S_2 \cdot y \\ S_3 \cdot z \\ 1 \end{pmatrix}\]</span></p>

<p>Note que mantemos o quarto valor de escala como 1. O componente <strong>w</strong> é usado para outros fins, como veremos mais tarde.</p>

<h3 id="translação">Translação</h3>

<p>A <span style="color:green">translação </span>
 é o processo de adição de um outro vetor em cima do vetor original para obter um novo vetor com uma posição diferente, <em>movendo-se</em> assim o vetor baseado em um vetor de translação. Nós já falamos sobre adição de vetores de modo que isto não deve ser muito novo.</p>

<p>Assim como a matriz de escala existem vários locais em uma matriz de 4 por 4, que podemos usar para executar determinadas operações, e para a translação esses são os 3 principais valores da quarta coluna. Se nós representasse-mos o vetor de translação como $(T_x, T_y,  T_z)$ poderíamos definir a matriz de translação    por:</p>

<p><span  class="math">\[\begin{bmatrix}  1 &  0 &  0 & T_x \\  0 &  1 &  0 &  T_y \\  0 &  0 &  1 &  T_z \\  0 &  0 &  0 &  1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ \end{pmatrix} = \begin{pmatrix} x + T_x \\ y + T_y \\ z + T_z \\ 1 \end{pmatrix}\]</span></p>

<p>Isso funciona porque todos os valores de translação são multiplicados pela linha <strong>w</strong> do vetor e acrescentados aos valores originais do vetor (lembre-se das regras de multiplicação de matrizes). Isto não teria sido possível com uma matriz 3-por-3.</p>


<div class="mynotices tip" ><p><strong>Coordenadas Homogeneas</strong></p>

<p>A componente <strong>w</strong> de um vetor é também conhecida como uma <span style="color:green">coordenada homogênea </span>
. Para se extrair um vetor 3D de um vetor homogêneo dividimos as coordenadas <strong>x</strong>, <strong>y</strong> e <strong>z</strong> pela coordenada <strong>w</strong>. Normalmente não percebemos isso já que a componente <strong>w</strong> vale <strong>1.0</strong> a maior parte do tempo. O uso das coordenadas homogêneas tem muitas vantagens: permite aplicarmos matrizes de translação em vetores 3D (sem uma componente <strong>w</strong> não podemos transladar vetores) e no próximo capítulo vamos usar o valor <strong>w</strong> para criar perspectiva 3D.</p>

<p>Além disso, sempre que a coordenada homogênea for igual a 0, o vetor é conhecido especificamente como um <span style="color:green">vetor direção </span>
 já que um vetor com coordenada <strong>w</strong> igual a 0 não pode ser transladado.</p>
</div>


<p>Com uma matriz de translação podemos mover objetos em qualquer uma das 3 direções dos eixos (<strong>x</strong>, <strong>y</strong>, <strong>z</strong>), tornando-se uma matriz de transformação muito útil para a nossa caixa de ferramentas de transformação.</p>

<h3 id="rotação">Rotação</h3>

<p>As últimas transformações eram relativamente fáceis de entender e visualizar nos espaços 2D ou 3D, mas rotações são um pouco mais complicadas. Se você quer saber exatamente como essas matrizes são construídas eu recomendo que você assista os itens de rotação dos vídeos de <a href="https://www.khanacademy.org/math/linear-algebra/matrix_transformations">álgebra linear</a> da Khan Academy.</p>

<p>Primeiro vamos definir o que uma rotação de um vetor é realmente. Uma rotação em 2D ou 3D é representada com um <span style="color:green">ângulo </span>
. Um ângulo poderia estar em graus ou radianos, onde um círculo completo tem 360 graus ou 2 <a href="http://en.wikipedia.org/wiki/Pi">PI</a> radianos. Eu prefiro explicar rotações usando graus já que geralmente mais acostumados a eles.</p>


<div class="mynotices tip" ><p>A maioria das funções de rotação requerem um ângulo em radianos, mas graus felizmente são facilmente convertidos em radianos:</p>

<p>ângulo em graus de ângulo em radianos = * (180 / PI)</p>

<p>ângulo em radianos = ângulo em graus * (PI / 180)</p>

<p>Onde PI é igual a <strong>3.14159265359</strong>.</p>
</div>


<p>A rotação pela metade de um círculo nos gira 360/2 = 180 graus e a rotação de 1/5 para a direita significa que giramos 360/5 = 72 graus para a direita. Isto é demonstrado por uma vetor 2D onde $\bar{v}$ é rotacionado de 72 graus para a direita, ou no sentido horário, a partir de $\bar{k}$:</p>

<p><figure><img src="https://learnopengl.com/img/getting-started/vectors_angle.png" alt="altlogo"></figure></p>

<p>Rotações em 3D são especificados com um ângulo e de um <span style="color:green">eixo de rotação </span>
. O ângulo específico, vai rodar o objecto ao longo do eixo de rotação dado. Tente visualizar girando sua cabeça um certo grau enquanto continuamente olhando para na direção de um eixo de rotação único. Ao rodar os vetores 2D num mundo 3D por exemplo, definimos o eixo de rotação para o eixo z (tente visualizar).</p>

<p>Usando a trigonometria, é possível transformar vetores para novos vetores girados a um ângulo. Isso geralmente é feito através de uma combinação inteligente das funções <strong>seno</strong> e <strong>cosseno</strong> (comumente abreviados para <strong>sin</strong> e <strong>cos</strong>). A discussão de como as matrizes de rotação são geradas está fora do escopo deste capítulo.</p>

<p>Uma matriz de rotação é definida para cada eixo unitário no espaço 3D, onde o ângulo é representado como o símbolo teta $\theta$.</p>

<p>Rotação em torno do eixo-X:</p>

<p><span  class="math">\[\begin{bmatrix}  1 &  0 &  0 &  0 \\  0 &  \cos \theta & -\sin\theta &  0 \\  0 &  \sin\theta &  \cos\theta &  0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} x \\  \cos\theta \cdot y -  \sin\theta \cdot z \\  \sin\theta \cdot y +  \cos\theta \cdot z \\ 1 \end{pmatrix}\]</span></p>

<p>Rotação em torno do eixo Y:</p>

<p><span  class="math">\[\begin{bmatrix} \cos\theta &  0 &   \sin\theta &  0 \\  0 &  1 &  0 &  0 \\ -  \sin\theta &  0 &  \cos\theta &  0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix}  \cos\theta \cdot x +  \sin\theta \cdot z \\ y \\ -  \sin\theta \cdot x +  \cos \theta \cdot z \\ 1 \end{pmatrix}\]</span></p>

<p>Rotação em torno do eixo Z:</p>

<p><span  class="math">\[\begin{bmatrix} \cos\theta & - \sin\theta &  0 &  0 \\ \sin\theta &  \cos \theta &  0 &  0 \\  0 &  0 &  1 &  0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \cdot \begin{pmatrix} x \\ y \\ z \\ 1 \end{pmatrix} = \begin{pmatrix} \cos\theta \cdot x -  \sin\theta \cdot y \\  \sin\theta \cdot x + \cos\theta \cdot y \\ z \\ 1 \end{pmatrix}\]</span></p>

<p>Usando as matrizes de rotação podemos transformar os nossos vetores posição em torno de um dos três eixos unitários. Para girar em torno de um eixo 3D arbitrário podemos combinar todos 3, em primeiro lugar girar em torno do eixo X, em seguida, Y e Z, por exemplo. No entanto, isto rapidamente introduz um problema chamado <span style="color:green">Gimbal Lock </span>
. Não vamos discutir os detalhes, mas uma solução melhor para girar em torno de um eixo unitário arbitrário por exemplo <strong>(0.662,0.2,0.722)</strong> (note que este é um vetor unitário) de imediato, em vez de combinar as matrizes de rotação. Tal matriz existe e é dada abaixo com $(R_x,R_y,R_z)$ como o eixo de rotação arbitrária:</p>

<p><span  class="math">\[\begin{bmatrix} \cos \theta +   R_x^2 (1 - \cos\theta) &   {R_x}  {R_y} (1 - \cos \theta) -  {R_z} \sin \theta &   {R_x}  {R_z} (1 - \cos \theta) +  { R_y} \sin \theta & 0 \\  {R_y}   {R_x} (1 - \cos \theta) +  {R_z} \sin \theta & \cos \theta +  {R_y} ^ 2 (1 - \cos \theta) & {R_y}  {R_z}  (1 - \cos \theta) - R_x \sin \theta & 0 \\  {R_z}   {R_x} (1 - \cos \theta) -  {R_y} \sin \theta &  {R_z}  {R_y} (1 - \cos \theta) +   {R_x} \sin \theta & \cos \theta +  { R_z} ^ 2 (1 - \cos \theta) & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}\]</span></p>

<p>Uma discussão matemática sobre gerar tal matriz está fora do âmbito deste capítulo. Tenha em mente que mesmo essa matriz não impede completamente Gimbal locks (embora fique muito mais difícil). Para evitar que verdadeiramente Gimbal locks temos que representar rotações usando <span style="color:green">quaternions </span>
, que não só são mais seguros, mas também computacionalmente mais amigáveis. No entanto, uma discussão sobre quaternions está fora do escopo deste capítulo.</p>

<h3 id="combinando-matrizes">Combinando Matrizes</h3>

<p>O verdadeiro poder de usar matrizes para transformações é que podemos combinar várias transformações em uma única matriz, graças à multiplicação de matriz-matriz. Vamos ver se podemos gerar uma matriz de transformação que combina várias transformações. Digamos que temos um vetor <strong>(x, y, z)</strong> e que queremos dimensioná-lo por 2 e, em seguida, movê-lo por <strong>(1,2,3)</strong>. Precisamos de uma matriz de translação e uma matriz de escala para nossos passos. A matriz de transformação resultante seria semelhante a:</p>

<p><span  class="math">\[Trans. Escala = \begin{bmatrix}  1 &  0 &  0 &  1 \\  0 &  1 &  0 &  2 \\  0 &  0 &  1 &  3 \\  0 & 0 & 0 &  1 \end{bmatrix}. \begin{bmatrix}  2 &  0 &  0 &  0 \\  0 &  2 &  0 &  0 \\  0 &  0 &  2 &  0 \\  0 &  0 &  0 &  1 \end{bmatrix} = \begin{bmatrix}  2 &  0 &  0 &  1 \\  0 &  2 &  0 &  2 \\  0 &  0 &  2 &  3 \\  0 &  0 &  0 &  1 \end{bmatrix}\]</span></p>

<p>Note que primeiro fazemos uma translação e, em seguida, uma transformação de escala ao multiplicar matrizes. A multiplicação de matrizes não é comutativa, o que significa que sua ordem é importante. Ao multiplicar matrizes, a matriz mais à direita é multiplicada primeiro com o vetor de modo que você deve ler as multiplicações da direita para a esquerda. É aconselhável primeiro fazer escalas, em seguida, rotações e, por último translações quando combinando matrizes, caso contrário elas podem (negativamente) afetar umas as outras. Por exemplo, se você primeiro fazer uma translação e, em seguida, escala, o vetor de translação também será escalado!</p>

<p>Executando a matriz de transformação final sobre nosso vetor resulta em:</p>

<p><span  class="math">\[\begin{bmatrix}  2 &  0 &  0 &  1 \\  0 &  2 &  0 &  2 \\  0 &  0 &  2 &  3 \\ 0 &  0 &  0 &  1 \end{bmatrix}. \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} = \begin{bmatrix}  2x +  1 \\  2y +  2 \\  + 2z  3 \\ 1 \end{bmatrix}\]</span></p>

<p>Ótimo! O vetor é primeiramente escalonado por dois e, em seguida, transladado por <strong>(1,2,3)</strong>.</p>

<h2 id="na-prática">Na Prática</h2>

<p>Agora que nós explicamos toda a teoria por trás de transformações, é hora de ver como nós podemos realmente usar esse conhecimento para nossa vantagem. A OpenGL não tem qualquer forma de conhecimento de matriz ou vetor embutidos, por isso temos de definir nossas próprias classes de matemática e funções. Neste livro, prefiro abstrair de todos os pequenos detalhes matemáticos e simplesmente usar bibliotecas pré-fabricadas de matemática. Felizmente, há uma biblioteca matemática adaptada para OpenGL fácil de usar e chamada GLM.</p>

<h3 id="glm">GLM</h3>

<p>GLM significa Open<strong>GL</strong> <strong>M</strong>athematics e é uma biblioteca de <em>apenas cabeçalhos</em>, o que significa que só temos de incluir os arquivos de cabeçalho adequados e estamos prontos; sem vinculação e compilação necessárias.
  A GLM pode ser baixada de seu <a href="https://glm.g-truc.net/0.9.8/index.html">site</a>. Copie o diretório raiz dos arquivos de cabeçalho em sua pasta <em>include</em> e vamos brincar.</p>

<p><figure><img src="https://learnopengl.com/img/getting-started/glm.png" alt="altlogo"></figure></p>

<p>A maioria das funcionalidades da GLM que precisamos podem ser encontradas em 3 arquivos cabeçalhos que vamos incluir a seguir:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;glm/glm.hpp&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;glm/gtc/matrix_transform.hpp&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;glm/gtc/type_ptr.hpp&gt;</span><span style="color:#75715e">
</span></code></pre></div>
<p>Vamos ver se podemos colocar nosso conhecimento de transformações em prática, transladando um vetor de <strong>(1,0,0)</strong> por <strong>(1,1,0)</strong> (note que o definimos como <strong>glm::vec4</strong> com sua coordenada homogênea definida para <strong>1.0</strong>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">glm<span style="color:#f92672">::</span>vec4 vec(<span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">1.0f</span>);
glm<span style="color:#f92672">::</span>mat4 trans <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>mat4(<span style="color:#ae81ff">1.0f</span>);
trans <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>translate(trans, glm<span style="color:#f92672">::</span>vec3(<span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">0.0f</span>));
vec <span style="color:#f92672">=</span> trans <span style="color:#f92672">*</span> vec;
std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> vec.x <span style="color:#f92672">&lt;&lt;</span> vec.y <span style="color:#f92672">&lt;&lt;</span> vec.z <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</code></pre></div>
<p>Nós primeiro definimos um vetor chamado <strong>vec</strong> usando a classe de vetor da GLM. Em seguida, definimos uma <strong>mat4</strong> e a inicializamos explicitamente com uma matriz identidade ao definir a diagonal da matriz com <strong>1.0</strong>; se não inicializar com a matriz identidade a matriz seria uma matriz nula (todos os elementos 0) e todas as operações da matriz subseqüentes iriam acabar em uma matriz nula também.</p>

<p>O próximo passo é para criar uma matriz de transformação, passando a matriz de identidade para a função a <strong>glm::translate</strong>, juntamente com um vetor de translação (a matriz é então multiplicada por uma matriz de translação e a matriz resultante é devolvida).</p>
<pre><code>Depois multiplicamos nosso vetor pela matriz de transformação. Se ainda nos lembramos como a matriz de translação funciona, então o vetor resultante deve ser **(1 + 1,0 + 1,0 + 0)** que é **(2,1,0)**. Este trecho de código gera **210** de modo a matriz de translação fez o seu trabalho.</code></pre>
<p>Vamos fazer algo mais interessante e escalar e girar o objeto do capítulo anterior:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">glm<span style="color:#f92672">::</span>mat4 trans <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>mat4(<span style="color:#ae81ff">1.0f</span>);
trans <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>rotate(trans, glm<span style="color:#f92672">::</span>radians(<span style="color:#ae81ff">90.0f</span>), glm<span style="color:#f92672">::</span>vec3(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>));
trans <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>scale(trans, glm<span style="color:#f92672">::</span>vec3(<span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>));  
</code></pre></div>
<p>Em primeiro lugar, dimensionamos o objeto de <strong>0.5</strong> em cada um dos eixos e em seguida rodamos o objeto 90 graus em torno do eixo Z. A GLM espera seus ângulos em radianos, então convertemos os graus em radianos usando <strong>glm::radianos</strong>. Note que o retângulo texturizado está no plano XY por isso queremos girar em torno do eixo Z. Tenha em mente que o eixo que giramos em torno deve ser um vetor de unidade, por isso tenha certeza de normalizar o vetor primeiro se você não está girando em torno do eixo X, Y ou Z. Como passamos a matriz para cada uma das funções da GLM, a GLM automaticamente multiplica as matrizes em conjunto, resultando em uma matriz de transformação que combina todas as transformações.</p>

<p>A próxima grande questão é: como é que vamos acessar a matriz de transformação dos shaders? Nós brevemente mencionamos antes que a GLSL também tem um tipo <strong>mat4</strong>. Então, vamos adaptar o shader de vértice para aceitar uma variável uniforme <strong>mat4</strong> e multiplicar o vetor posição pelo uniforme de matriz:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#version 330 core
</span><span style="color:#75715e"></span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) in vec3 aPos;
layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) in vec2 aTexCoord;

out vec2 TexCoord;
  
uniform mat4 transform;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
{
    gl_Position <span style="color:#f92672">=</span> transform <span style="color:#f92672">*</span> vec4(aPos, <span style="color:#ae81ff">1.0f</span>);
    TexCoord <span style="color:#f92672">=</span> vec2(aTexCoord.x, aTexCoord.y);
} 
</code></pre></div>

<div class="mynotices tip" ><p>A GLSL também tem os tipos <strong>mat2</strong> e <strong>mat3</strong> que permitem operações de <em>swizzling</em> assim como vetores. Todas as operações matemáticas acima mencionados (tais como multiplicação escalar-matriz, a multiplicação de matriz-vetor e multiplicação matriz-matriz) são permitidos nos tipos de matriz. Onde quer que sejam utilizadas operações especiais com matrizes, vamos explicar o que está acontecendo.</p>
</div>


<p>Adicionamos o uniforme e multiplicamos o vetor de posição com a matriz de transformação antes de passá-lo para <span style="color:blue">gl_Position</span>
. O nosso objeto deve agora ser duas vezes mais pequeno e rotationado 90 graus (inclinado para a esquerda). No entanto, ainda precisamos passar a matriz de transformação para o shader:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> transformLoc <span style="color:#f92672">=</span> glGetUniformLocation(ourShader.ID, <span style="color:#e6db74">&#34;transform&#34;</span>);
glUniformMatrix4fv(transformLoc, <span style="color:#ae81ff">1</span>, GL_FALSE, glm<span style="color:#f92672">::</span>value_ptr(trans));
</code></pre></div>
<p>Em primeiro lugar, consultamos a localização da variável uniforme e, em seguida, enviamos os dados da matriz para os shaders utilizando <a href=""><span style="color:red">glUniform </span></a>
 com <strong>Matrix4fv</strong> como posfixo. O primeiro argumento deve ser familiar agora, que é a localização do uniforme. O segundo argumento diz a OpenGL quantas matrizes gostaríamos de enviar, que é 1. O terceiro argumento nos pergunta se queremos transpor nossa matriz, que é trocar as colunas e linhas. desenvolvedores OpenGL costumam usar um layout de matriz interna chamada <span style="color:green">column-major ordering </span>
 que é o layout da matriz padrão no GLM por isso não há necessidade de transpor as matrizes; podemos mantê-lo em <span style="color:blue">GL_FALSE</span>
. O último parâmetro são os dados da matriz, mas GLM armazena os dados de suas matrizes de uma maneira que nem sempre corresponde às expectativas da OpenGL, então primeiro convertemos os dados com a função da GLM <a href=""><span style="color:red">value_ptr </span></a>
.</p>

<p>Nós criamos uma matriz de transformação, declaramos um uniforme no shader de vértice e enviamos a matriz para os shaders que transformam nossas coordenadas dos vértices. O resultado deve ser algo como isto:</p>

<p><figure><img src="https://learnopengl.com/img/getting-started/transformations.png" alt="altlogo"></figure></p>

<p>Perfeito! Nosso objeto está realmente inclinado para a esquerda e duas vezes mais pequeno logo a transformação foi bem sucedida. Vamos brincar um pouco mais e ver se podemos rodar o objeto ao longo do tempo, e para se divertir também vamos reposicionar o objeto no lado inferior direito da janela.
Para roda-lo ao longo do tempo nós temos que atualizar a matriz de transformação no loop de renderização porque ele precisa ser atualizado a cada quadro. Nós usamos a função do tempo da GLFW para obter um ângulo ao longo do tempo:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">glm<span style="color:#f92672">::</span>mat4 trans <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>mat4(<span style="color:#ae81ff">1.0f</span>);
trans <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>translate(trans, glm<span style="color:#f92672">::</span>vec3(<span style="color:#ae81ff">0.5f</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">0.5f</span>, <span style="color:#ae81ff">0.0f</span>));
trans <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>rotate(trans, (<span style="color:#66d9ef">float</span>)glfwGetTime(), glm<span style="color:#f92672">::</span>vec3(<span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">1.0f</span>));
</code></pre></div>
<p>Tenha em mente que no caso anterior, poderíamos declarar a matriz de transformação  em qualquer lugar, mas agora temos que criá-la cada iteração para atualizar continuamente a rotação. Isto significa que temos para recriar a matriz de transformação em cada iteração do loop de renderização. Normalmente, na renderização de cenas temos várias matrizes de transformação que são recriadas com novos valores cada quadro.</p>

<p>Aqui podemos rodar o objeto em torno da origem <strong>(0,0,0)</strong> e uma vez que é rodado, transladamos a sua versão rotacionada para o canto inferior direito da tela. Lembre-se que a ordem de transformação deve ser lida ao contrário: mesmo que no código primeiro translademos e depois giremos, as transformações reais primeiro aplicam uma rotação e depois uma translação. Compreender todas estas combinações de transformações e como se aplicam a objetos é difícil de entender. Experimente e tentar transformações como estas e você vai rapidamente ter uma idéia melhor.</p>

<p>Se você fez as coisas direito, deve obter o seguinte resultado:</p>

<p><figure><img src="https://learnopengl.com/img/getting-started/transformations2.png" alt="altlogo"></figure></p>

<p>E aí está. Um objeto transladado que é rotacionando com o tempo, tudo feito por uma única matriz de transformação! Agora você pode ver porque matrizes são uma construção tão poderosa na terra dos gráficos. Podemos definir uma quantidade infinita de transformações e combiná-las em uma única matriz que podemos voltar a usar tão frequentemente como gostaríamos. Usando transformações como esta no shader de vértice nos salva o esforço de redefinição dos dados de vértice e nos poupa algum tempo de processamento, bem como, uma vez que não temos que re-enviar os nossos dados o tempo todo (que é bastante lento); tudo o que precisamos fazer é atualizar o uniforme de transformação.</p>

<p>Se você não obter o resultado correto ou se você estiver preso(a) em algum lugar, dê uma olhada no <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/5.1.transformations/transformations.cpp">código fonte</a> e a classe <a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/shader_m.h">shader</a> atualizada.</p>

<p>No próximo capítulo vamos discutir como podemos usar matrizes para definir diferentes espaços de coordenadas para os nossos vértices. Este será o nosso primeiro passo para os gráficos 3D!</p>

<h1 id="leitura-adicional">Leitura Adicional</h1>

<ul>
<li><a href="https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">Essence of Linear Algebra</a>: grande série de vídeo tutoriais por Grant Sanderson sobre a matemática que envolve transformações e álgebra linear.</li>
</ul>

<h1 id="exercícios">Exercícios</h1>

<ul>
<li><p>Utilizando a última transformação no objeto, tente trocar a ordem para primeiro rotacionar e, em seguida, transladar. Veja o que acontece e tentar entender por que isso acontece: <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/5.2.transformations_exercise1/transformations_exercise1.cpp">solução</a>.</p></li>

<li><p>Tente desenhar um segundo objeto com outra chamada para <a href=""><span style="color:red">glDrawElements </span></a>
, mas coloque-o em uma posição diferente, utilizando apenas transformações. Certifique-se que este segundo objeto é colocado no canto superior esquerdo da janela e, em vez de girá-lo, escale-o ao longo do tempo (a função <strong>sin</strong> é útil aqui, note que o uso de <strong>sin</strong> fará com que o objeto seja invertido assim que uma escala negativa é aplicada): <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/5.2.transformations_exercise2/transformations_exercise2.cpp">solução</a>.</p></li>
</ul>





<footer class=" footline" >
	
</footer>

        
        </div>
        

      </div>
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'aprendaopengl-1';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


    <div id="navigation">
        
        

        
            
            
                
                    
                    
                
                

                    
                    
                        
                    
                    

                    
                        
            
            
                
                    
                        
                        
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                    
                
                

                    
                    
                        
                    
                    

                    
                        
            
            
                
                    
                        
                        
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                        
                        
                    
                
                

                    
                    
                        
                    
                    

                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                        
                    
                    

                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                        
                    
                    

                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
            
        

        


	 
	 
		
			<a class="nav nav-prev" href="/aprendaopengl/ponto_de_partida/ola_triangulo/" title="Olá Triângulo"> <i class="fa fa-chevron-left"></i></a>
		
		
			<a class="nav nav-next" href="/aprendaopengl/iluminacao/" title="Iluminação" style="margin-right: 0px;"><i class="fa fa-chevron-right"></i></a>
		
	
    </div>

    </section>

    <div style="left: -1000px; overflow: scroll; position: absolute; top: -1000px; border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;">
      <div style="border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;"></div>
    </div>
    <script src="/aprendaopengl/js/clipboard.min.js?1609944863"></script>
    <script src="/aprendaopengl/js/perfect-scrollbar.min.js?1609944863"></script>
    <script src="/aprendaopengl/js/perfect-scrollbar.jquery.min.js?1609944863"></script>
    <script src="/aprendaopengl/js/jquery.sticky.js?1609944863"></script>
    <script src="/aprendaopengl/js/featherlight.min.js?1609944863"></script>
    <script src="/aprendaopengl/js/highlight.pack.js?1609944863"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="/aprendaopengl/js/modernizr.custom-3.6.0.js?1609944863"></script>
    <script src="/aprendaopengl/js/learn.js?1609944863"></script>
    <script src="/aprendaopengl/js/hugo-learn.js?1609944863"></script>
    
        
            <script src="/aprendaopengl/mermaid/mermaid.js?1609944863"></script>
        
        <script>
            mermaid.initialize({ startOnLoad: true });
        </script>
    
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-85882787-1', 'auto');
  ga('send', 'pageview');

</script>

  </body>
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>

</html>
